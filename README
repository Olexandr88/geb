# The GEB Manual

###### \[in package GEB-DOCS/DOCS\]
Welcome to the GEB project.

## Links

Here is the [official repository](https://github.com/anoma/geb/)
and the [HTML documentation](https://anoma.github.io/geb/) for the latest version

## Getting Started

Welcome to the GEB Project!

### installation

This project uses [common lisp](https://common-lisp.net/), so a few
   dependencies are needed to get around the code-base and start hacking. Namely:

1. [lisp with quicklisp](https://lisp-lang.org/learn/getting-started/).

2. [Emacs](https://en.wikipedia.org/wiki/Emacs) along with one of the following:

    - [sly](https://github.com/joaotavora/sly)

        - [sly user manual](http://joaotavora.github.io/sly/)

    - [slime](https://github.com/slime/slime)

        - [slime user manual](http://www.chiark.greenend.org.uk/doc/slime/slime.pdf)


### loading

Now that we have an environment setup, we can load the project, this
   can be done in a few steps.

1. Open the `REPL` (sbcl (terminal), `M-x` sly, `M-x` swank)

    - For the terminal, this is just calling the [common
       lisp](https://common-lisp.net/) implementation from the
       terminal.

        `user@system:geb-directory % sbcl`.

    - For Emacs, this is simply calling either `M-x sly` or `M-x slime`
       if you are using either [sly](https://github.com/joaotavora/sly) or [slime](https://github.com/slime/slime)

2. From Emacs: open `geb.asd` and press `C-ck` (`sly-compile-and-load-file`, or
   `swank-compile-and-load-file` if you are using swank).

Now that we have the file open, we can now load the system by
writing:

```lisp
;; only necessary for the first time!
(ql:quickload :geb/documentation)

;; if you want to load it in the future
(asdf:load-system :geb/documentation)

;; if you want to load the codbase and run tests at the same time
(asdf:test-system :geb/documentation)

;; if you want to run the tests once the system is loaded!
(geb-test:run-tests)
```


## Original Efforts

Originally GEB started off as an Idris codebase written by the
designer and creator of GEB, Terence Rokop, However further efforts
spawned for even further formal verification by Artem Gureev. Due
to this, we have plenty of code not in Common Lisp that ought to be
a good read.

### Geb's Idris Code

The Idris folder can be found in the
[geb-idris](https://github.com/anoma/geb/tree/main/geb-idris) folder
provided in the codebase

At the time of this document, there is over 16k lines of Idris code
written. This serves as the bulk of the POC that is GEB and is a
treasure trove of interesting information surrounding category
theorey.

### Geb's Agda Code

The Agda folder can be found in the
[geb-agda](https://github.com/anoma/geb/tree/main/geb-agda) folder
provided in the codebase

The Agda codebase serves as a great place to view formally verified
properties about the GEB project. Although @IDRIS is written in a
dependently typed language, it serves as reference example of GEB,
while @AGDA serves as the mathematical formalism proving various
conjectures about GEB

## Categorical Model

GEB is organizing programming language concepts
using [category theory](https://plato.stanford.edu/entries/category-theory/),
originally developped by mathematicians,
but very much alive in (theoretical) computer science.

### Morphisms


### Objects


## The Geb Model

###### \[in package GEB.SPEC\]
Everything here relates directly to the underlying machinery of
GEB, or to abstractions that help extend it.

### Core Categories

The underlying category of GEB. With @GEB-SUBSTMU covering the
shapes and forms (GEB-DOCS/DOCS:@OBJECTS) of data while @GEB-SUBSTMORPH
deals with concrete GEB-DOCS/DOCS:@MORPHISMS within the category

#### Subst Obj

This section covers the objects of the GEB category. Every value
that is a SUBSTOBJ is automatically lifted into a SUBSTMORPH when a
SUBSTMORPH is expected.

The Type that encomposes the SUBSTOBJ class

- [type] SUBSTOBJ

- [type] <SUBSTOBJ>

    the class corresponding to SUBSTOBJ

The various constructors that form the SUBSTOBJ type

- [type] PROD

    the product

- [type] COPROD

    the coproduct

- [type] SO0

    The Initial/Void Object

- [type] SO1

    The Terminal/Unit Object

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMU

- [method] MCAR (PROD PROD)

- [method] MCADR (PROD PROD)

- [method] MCAR (COPROD COPROD)

- [method] MCADR (COPROD COPROD)

#### Subst Morph

The moprhisms of the GEB category.

The Type that encomposes the SUBSTMOPRH class

- [type] SUBSTMORPH

- [type] <SUBSTMORPH>

    the class type corresponding to SUBSTMORPH

The various constructors that form the SUBSTMORPH type

- [type] COMP

    Composition of morphism

- [type] CASE

    Coproduct elimination (case statement)

- [type] INIT

    The initial Morphism

- [type] TERMINAL

    The terminal Morhpism

- [type] PAIR

    Product introduction (morphism pairing)

- [type] DISTRIBUTE

    The distributive law

- [type] INJECT-LEFT

    Left injection (coproduct introduction)

- [type] INJECT-RIGHT

    Right injection (coproduct introduction)

- [type] PROJECT-LEFT

    Left projection (product elimination)

- [type] PROJECT-RIGHT

- [type] FUNCTOR

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMORPH

- [method] MCAR (COMP COMP)

    The first composed morphism

- [method] MCADR (COMP COMP)

    the second morphism

- [method] OBJ (INIT INIT)

- [method] OBJ (INIT INIT)

- [method] MCAR (CASE CASE)

- [method] MCADR (CASE CASE)

- [method] MCAR (PAIR PAIR)

    Head of the pair cell

- [method] MCDR (PAIR PAIR)

    Tail of the pair cell

- [method] MCAR (DISTRIBUTE DISTRIBUTE)

- [method] MCADR (DISTRIBUTE DISTRIBUTE)

- [method] MCADDR (DISTRIBUTE DISTRIBUTE)

- [method] MCAR (INJECT-LEFT INJECT-LEFT)

- [method] MCADR (INJECT-LEFT INJECT-LEFT)

- [method] MCAR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCADR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCAR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCADR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCAR (PROJECT-RIGHT PROJECT-RIGHT)

- [method] MCADR (PROJECT-RIGHT PROJECT-RIGHT)

    Right projection (product elimination)

### Accessors

###### \[in package GEB.UTILS\]
These functions are generic lenses of the GEB codebase. If a class is
defined, where the names are not known, then these accessors are
likely to be used. They may even augment existing classes.

- [generic-function] MCAR OBJ

    Can be seen as calling CAR on a generic CLOS
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] MCADR OBJ

    like MCAR but for the CADR

- [generic-function] MCADDR OBJ

    like MCAR but for the CADDR

- [generic-function] MCADDDR OBJ

    like MCAR but for the CADDDR

- [generic-function] MCDR OBJ

    Similar to MCAR, however acts like a CDR for
    classes that we wish to view as a SEQUENCE

- [generic-function] OBJ OBJ

    Grabs the underlying
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] NAME OBJ

    the name of the given
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] FUNC OBJ

    the function of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] PREDICATE OBJ

    the PREDICATE of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] THEN OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] ELSE OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

### Constructors

The API for creating GEB terms. All the functions and variables
here relate to instantiating a term

- [variable] *SO0* s-0

    The Initial Object

- [variable] *SO1* s-1

    The Terminal Object

More Ergonomic API variants for *SO0* and *SO1*

- [symbol-macro] SO0

- [symbol-macro] SO1

- [function] MAKE-ALIAS &KEY NAME OBJ

- [function] <-LEFT MCAR MCADR

    projects left constructor

- [function] <-RIGHT MCAR MCADR

    projects right constructor

- [function] LEFT-> MCAR MCADR

    injects left constructor

- [function] RIGHT-> MCAR MCADR

    injects right constructor

- [function] MCASE MCAR MCADR

- [function] MAKE-FUNCTOR &KEY OBJ FUNC

### api

Various functions that make working with GEB easier

- [function] PAIR-TO-LIST PAIR &OPTIONAL ACC

    converts excess pairs to a list format

- [function] SAME-TYPE-TO-LIST PAIR TYPE &OPTIONAL ACC

    converts the given type to a list format

- [function] MLIST V1 &REST VALUES

- [function] COMMUTES X Y

- [function] !-> A B

- [function] SO-EVAL X Y

### Examples

PLACEHOLDER: TO SHOW OTHERS HOW EXAMPLES WORK

Let's see the transcript of a real session of someone working
with GEB:

```common-lisp
(values (princ :hello) (list 1 2))
.. HELLO
=> :HELLO
=> (1 2)

(+ 1 2 3 4)
=> 10
```


## Polynomial Specification

###### \[in package GEB.POLY.SPEC\]
This covers a GEB view of Polynomials. In particular this type will
be used in translating GEB's view of Polynomials into Vampir

### Polynomial Types

This section covers the types of things one can find in the POLY
constructors

- [type] POLY

- [type] <POLY>

- [type] IDENT

    The Identity Element

- [type] +

- [type] *

- [type] /

- [type] -

- [type] MOD

- [type] COMPOSE

- [type] IF-ZERO

    compare with zero: equal takes first branch;
    not-equal takes second branch

- [type] IF-LT

    If the MCAR argument is strictly less than the MCADR then the
    THEN branch is taken, otherwise the ELSE branch is taken.

### Polynomial Constructors

Every accessor for each of the CLASS's found here are from @GEB-ACCESSORS

- [symbol-macro] IDENT

- [function] + MCAR MCADR &REST ARGS

    Creates a multiway constructor for +

- [function] * MCAR MCADR &REST ARGS

    Creates a multiway constructor for \*

- [function] / MCAR MCADR &REST ARGS

    Creates a multiway constructor for /

- [function] - MCAR MCADR &REST ARGS

    Creates a multiway constructor for -

- [function] MOD MCAR MCADR

    MOD ARG1 by ARG2

- [function] COMPOSE MCAR MCADR &REST ARGS

    Creates a multiway constructor for COMPOSE

- [function] IF-ZERO PRED THEN ELSE

    checks if PREDICATE is zero then take then THEN branch otherwise the ELSE branch

- [function] IF-LT MCAR MCADR THEN ELSE

    Checks if the MCAR is less than the MCADR and chooses the appropriate branch

## Mixins

###### \[in package GEB.MIXINS\]
Various [mixins](https://en.wikipedia.org/wiki/Mixin) of the
project. Overall all these offer various services to the rest of the
project

### Pointwise Mixins

Here we provide various mixins that deal with classes in a pointwise
manner. Normally, objects can not be compared in a pointwise manner,
instead instances are compared. This makes functional idioms like
updating a slot in a pure manner (allocating a new object), or even
checking if two objects are `EQUAL`-able adhoc. The pointwise API,
however, derives the behavior and naturally allows such idioms

- [class] POINTWISE-MIXIN

    Provides the service of giving point wise
    operations to classes

Further we may wish to hide any values inherited from our superclass
due to this we can instead compare only the slots defined directly
in our class

- [class] DIRECT-POINTWISE-MIXIN POINTWISE-MIXIN

    Works like POINTWISE-MIXIN, however functions on
    POINTWISE-MIXIN will only operate on direct-slots
    instead of all slots the class may contain.
    
    Further all `DIRECT-POINTWISE-MIXIN`'s are POINTWISE-MIXIN's

### Pointwise API

These are the general API functions on any class that have the
POINTWISE-MIXIN service.

Functions like TO-POINTWISE-LIST allow generic list traversal APIs to
be built off the key-value pair of the raw object form, while
OBJ-EQUALP allows the checking of functional equality between
objects. Overall the API is focused on allowing more generic
operations on classes that make them as useful for generic data
traversal as `LIST`'s are

- [generic-function] TO-POINTWISE-LIST OBJ

    Turns a given object into a pointwise LIST. listing
    the KEYWORD slot-name next to their value.

- [generic-function] OBJ-EQUALP OBJECT1 OBJECT2

    Compares objects with pointwise equality. This is a
    much weaker form of equality comparison than
    STANDARD-OBJECT EQUALP, which does the much
    stronger pointer quality

- [generic-function] POINTWISE-SLOTS OBJ

    Works like C2MOP:COMPUTE-SLOTS however on the object
    rather than the class

### Mixins Examples

Let's see some example uses of POINTWISE-MIXIN:

```common-lisp
(obj-equalp (geb:terminal geb:so1)
            (geb:terminal geb:so1))
=> t

(to-pointwise-list (geb:coprod geb:so1 geb:so1))
=> ((:MCAR . s-1) (:MCADR . s-1))
```


## Geb Utilities

###### \[in package GEB.UTILS\]
The Utilities package provide general utility functionality that is
used throughout the GEB codebase

- [function] SYMBOL-TO-KEYWORD SYMBOL

    Turns a symbol into a keyword

- [macro] MUFFLE-PACKAGE-VARIANCE &REST PACKAGE-DECLARATIONS

    Muffle any errors about package variance and stating exports out of order.
    This is particularly an issue for SBCL as it will error when using MGL-PAX
    to do the export instead of DEFPACKAGE.
    
    This is more modular thank
    [MGL-PAX:DEFINE-PACKAGE](https://melisgl.Githubc.io/mgl-pax-world/mgl-pax-manual.html#MGL-PAX:DEFINE-PACKAGE%20MGL-PAX:MACRO)
    in that this can be used with any package creation function like
    [UIOP:DEFINE-PACKAGE](https://privet-kitty.github.io/etc/uiop.html#UIOP_002fPACKAGE).
    
    Here is an example usage:
    
    ```lisp
         (geb.utils:muffle-package-variance
           (uiop:define-package #:geb.lambda-conversion
             (:mix #:trivia #:geb #:serapeum #:common-lisp)
             (:export
              :compile-checked-term :stlc-ctx-to-mu)))
    ```


- [function] SUBCLASS-RESPONSIBILITY OBJ

    Denotes that the given method is the subclasses
    responsibility. Inspired from Smalltalk

- [macro] MAKE-PATTERN OBJECT-NAME &REST CONSTRUCTOR-NAMES

    make pattern matching position style instead of record style. This
    removes the record constructor style, however it can be brought back
    if wanted
    
    ```lisp
    (defclass alias (<substmorph> <substobj>)
      ((name :initarg :name
             :accessor name
             :type     symbol
             :documentation "The name of the GEB object")
       (obj :initarg :obj
            :accessor obj
            :documentation "The underlying geb object"))
      (:documentation "an alias for a geb object"))
    
    (make-pattern alias name obj)
    ```


### Accessors

These functions are generic lenses of the GEB codebase. If a class is
defined, where the names are not known, then these accessors are
likely to be used. They may even augment existing classes.

- [generic-function] MCAR OBJ

    Can be seen as calling CAR on a generic CLOS
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] MCADR OBJ

    like MCAR but for the CADR

- [generic-function] MCADDR OBJ

    like MCAR but for the CADDR

- [generic-function] MCADDDR OBJ

    like MCAR but for the CADDDR

- [generic-function] MCDR OBJ

    Similar to MCAR, however acts like a CDR for
    classes that we wish to view as a SEQUENCE

- [generic-function] OBJ OBJ

    Grabs the underlying
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] NAME OBJ

    the name of the given
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] FUNC OBJ

    the function of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] PREDICATE OBJ

    the PREDICATE of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] THEN OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

- [generic-function] ELSE OBJ

    the then branch of the
    [object](http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_o.htm#object)

## Testing

###### \[in package GEB-TEST\]
We use [parachtue](https://quickref.common-lisp.net/parachute.html)
as our testing framework.

Please read the
[manual](https://quickref.common-lisp.net/parachute.html) for extra
features and how to better lay out future tests

- [function] RUN-TESTS &KEY (INTERACTIVE? NIL) (SUMMARY? NIL) (PLAIN? T) (DESIGNATORS '(GEB-TEST-SUITE))

    Here we run all the tests. We have many flags to determine how the
    tests ought to work
    
    ```lisp
    (run-tests :plain? nil :interactive? t) ==> 'interactive
    (run-tests :summary? t :interactive? t) ==> 'noisy-summary
    (run-tests :interactive? t)             ==> 'noisy-interactive
    (run-tests :summary? t)                 ==> 'summary
    (run-tests)                             ==> 'plain
    
    (run-tests :designators '(geb geb.lambda)) ==> run only those packages
    ```


* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
