# The GEB Manual

###### \[in package GEB-DOCS/DOCS with nicknames EXAMPLE-DOCS\]
Welcome to the GEB project

## Geb User manual

###### \[in package GEB\]
The Main GEB model. Everything here relates directly to the
underlying machinery of GEB, or to abstractions that help extend
it.

### Types

Types Surrounding the GEB categories

#### Subst Obj

This Category covers the objects of the GEB category. Every value
that is a SUBSTOBJ is automatically lifted into a SUBSTMORPH when a
SUBSTMORPH is expected.

The Type that encomposes the SUBSTOBJ category

- [type] SUBSTOBJ

The various constructors that form the SUBSTOBJ type

- [type] PROD

    the product

- [type] COPROD

    the coproduct

- [type] SO0

    The Initial/Void Object

- [type] SO1

    The Terminal/Unit Object

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMU

- [method] MCAR (PROD PROD)

- [method] MCADR (PROD PROD)

- [method] MCAR (COPROD COPROD)

- [method] MCADR (COPROD COPROD)

#### Subst Morph

The moprhisms of the GEB category.

The Type that encomposes the SUBSTMOPRH category

- [type] SUBSTMORPH

The various constructors that form the SUBSTMORPH type

- [type] COMP

    Composition of morphism

- [type] CASE

    Coproduct elimination (case statement)

- [type] INIT

    The initial Morphism

- [type] TERMINAL

    The terminal Morhpism

- [type] PAIR

    Product introduction (morphism pairing)

- [type] DISTRIBUTE

    The distributive law

- [type] INJECT-LEFT

    Left injection (coproduct introduction)

- [type] INJECT-RIGHT

    Right injection (coproduct introduction)

- [type] PROJECT-LEFT

    Left projection (product elimination)

- [type] PROJECT-RIGHT

- [type] FUNCTOR

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMORPH

- [method] MCAR (COMP COMP)

    The first composed morphism

- [method] MCADR (COMP COMP)

    the second morphism

- [method] OBJ (INIT INIT)

- [method] OBJ (INIT INIT)

- [method] MCAR (CASE CASE)

- [method] MCADR (CASE CASE)

- [method] MCAR (PAIR PAIR)

    Head of the pair cell

- [method] MCDR (PAIR PAIR)

    Tail of the pair cell

- [method] MCAR (DISTRIBUTE DISTRIBUTE)

- [method] MCADR (DISTRIBUTE DISTRIBUTE)

- [method] MCADDR (DISTRIBUTE DISTRIBUTE)

- [method] MCAR (INJECT-LEFT INJECT-LEFT)

- [method] MCADR (INJECT-LEFT INJECT-LEFT)

- [method] MCAR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCADR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCAR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCADR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCAR (PROJECT-RIGHT PROJECT-RIGHT)

- [method] MCADR (PROJECT-RIGHT PROJECT-RIGHT)

    Right projection (product elimination)

### Accessors

These functions relate to grabbing slots out of the various
@GEB-SUBSTMORPH and @GEB-SUBSTMU types. See those sections for
specific instance documentation

- [generic-function] MCAR OBJECT

- [generic-function] MCADR OBJECT

- [generic-function] MCDR OBJECT

- [generic-function] MCADDR OBJECT

- [generic-function] OBJ OBJECT

- [generic-function] NAME OBJECT

- [generic-function] FUNC OBJECT

### Constructors

The API for creating GEB terms. All the functions and variables
here relate to instantiating a term

- [variable] *SO0* s-0

    The Initial Object

- [variable] *SO1* s-1

    The Terminal Object

More Ergonomic API variants for *SO0* and *SO1*

- [symbol-macro] SO0

- [symbol-macro] SO1

- [function] MAKE-ALIAS &KEY NAME OBJ

- [function] <-LEFT MCAR MCADR

    projects left constructor

- [function] <-RIGHT MCAR MCADR

    projects right constructor

- [function] LEFT-> MCAR MCADR

    injects left constructor

- [function] RIGHT-> MCAR MCADR

    injects right constructor

- [function] MCASE MCAR MCADR

- [function] MAKE-FUNCTOR &KEY OBJ FUNC

### api

Various functions that make working with GEB easier

- [function] PAIR-TO-LIST PAIR &OPTIONAL ACC

    converts excess pairs to a list format

- [function] SAME-TYPE-TO-LIST PAIR TYPE &OPTIONAL ACC

    converts the given type to a list format

- [function] MLIST V1 &REST VALUES

- [function] COMMUTES X Y

- [function] !-> A B

- [function] SO-EVAL X Y

### Examples

PLACEHOLDER: TO SHOW OTHERS HOW EXAMPLES WORK

Let's see the transcript of a real session of someone working
with GEB:

```common-lisp
(values (princ :hello) (list 1 2))
.. HELLO
=> :HELLO
=> (1 2)

(+ 1 2 3 4)
=> 10
```


* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
