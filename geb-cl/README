# The GEB Manual

###### \[in package GEB-DOCS/DOCS\]
Welcome to the GEB project.

## Links

Here is the [official repository](https://github.com/anoma/geb/tree/main/geb-cl)
and the [HTML documentation](https://anoma.github.io/geb/) for the latest version

## Getting Started

Welcome to the GEB Project!

### installation

This project uses [common lisp](https://common-lisp.net/), so a few
   dependencies are needed to get around the code-base and start hacking. Namely:

1. [lisp with quicklisp](https://lisp-lang.org/learn/getting-started/).

2. [Emacs](https://en.wikipedia.org/wiki/Emacs) along with one of the following:

    - [sly](https://github.com/joaotavora/sly)

        - [sly user manual](http://joaotavora.github.io/sly/)

    - [slime](https://github.com/slime/slime)

        - [slime user manual](http://www.chiark.greenend.org.uk/doc/slime/slime.pdf)


### loading

Now that we have an environment setup, we can load the project, this
   can be done in a few steps.

1. Open the `REPL` (sbcl (terminal), `M-x` sly, `M-x` swank)

    - For the terminal, this is just calling the [common
       lisp](https://common-lisp.net/) implementation from the
       terminal.

        `user@system:geb-directory % sbcl`.

    - For Emacs, this is simply calling either `M-x sly` or `M-x slime`
       if you are using either [sly](https://github.com/joaotavora/sly) or [slime](https://github.com/slime/slime)

2. From Emacs: open `geb.asd` and press `C-ck` (`sly-compile-and-load-file`, or
   `swank-compile-and-load-file` if you are using swank).

Now that we have the file open, we can now load the system by
writing:

```lisp
;; only necessary for the first time!
(ql:quickload :geb/documentation)

;; if you want to load it in the future
(asdf:load-system :geb/documentation)

;; if you want to load the codbase and run tests at the same time
(asdf:test-system :geb/documentation)

;; if you want to run the tests once the system is loaded!
(geb-test:run-tests)
```


## Categorical Model

The GEB theoretical model is one of category theory

### Morphisms


### Objects


## The Geb Model

###### \[in package GEB\]
Everything here relates directly to the underlying machinery of
GEB, or to abstractions that help extend it.

### Core Categories

The underlying category of GEB. With @GEB-SUBSTMU covering the
shapes and forms (GEB-DOCS/DOCS:@OBJECTS) of data while @GEB-SUBSTMORPH
deals with concrete GEB-DOCS/DOCS:@MORPHISMS within the category

#### Subst Obj

This section covers the objects of the GEB category. Every value
that is a SUBSTOBJ is automatically lifted into a SUBSTMORPH when a
SUBSTMORPH is expected.

The Type that encomposes the SUBSTOBJ class

- [type] SUBSTOBJ

- [type] <SUBSTOBJ>

    the class corresponding to SUBSTOBJ

The various constructors that form the SUBSTOBJ type

- [type] PROD

    the product

- [type] COPROD

    the coproduct

- [type] SO0

    The Initial/Void Object

- [type] SO1

    The Terminal/Unit Object

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMU

- [method] MCAR (PROD PROD)

- [method] MCADR (PROD PROD)

- [method] MCAR (COPROD COPROD)

- [method] MCADR (COPROD COPROD)

#### Subst Morph

The moprhisms of the GEB category.

The Type that encomposes the SUBSTMOPRH class

- [type] SUBSTMORPH

- [type] <SUBSTMORPH>

    the class type corresponding to SUBSTMORPH

The various constructors that form the SUBSTMORPH type

- [type] COMP

    Composition of morphism

- [type] CASE

    Coproduct elimination (case statement)

- [type] INIT

    The initial Morphism

- [type] TERMINAL

    The terminal Morhpism

- [type] PAIR

    Product introduction (morphism pairing)

- [type] DISTRIBUTE

    The distributive law

- [type] INJECT-LEFT

    Left injection (coproduct introduction)

- [type] INJECT-RIGHT

    Right injection (coproduct introduction)

- [type] PROJECT-LEFT

    Left projection (product elimination)

- [type] PROJECT-RIGHT

- [type] FUNCTOR

- [type] ALIAS

    an alias for a geb object

The @GEB-ACCESSORS specific to @GEB-SUBSTMORPH

- [method] MCAR (COMP COMP)

    The first composed morphism

- [method] MCADR (COMP COMP)

    the second morphism

- [method] OBJ (INIT INIT)

- [method] OBJ (INIT INIT)

- [method] MCAR (CASE CASE)

- [method] MCADR (CASE CASE)

- [method] MCAR (PAIR PAIR)

    Head of the pair cell

- [method] MCDR (PAIR PAIR)

    Tail of the pair cell

- [method] MCAR (DISTRIBUTE DISTRIBUTE)

- [method] MCADR (DISTRIBUTE DISTRIBUTE)

- [method] MCADDR (DISTRIBUTE DISTRIBUTE)

- [method] MCAR (INJECT-LEFT INJECT-LEFT)

- [method] MCADR (INJECT-LEFT INJECT-LEFT)

- [method] MCAR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCADR (INJECT-RIGHT INJECT-RIGHT)

- [method] MCAR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCADR (PROJECT-LEFT PROJECT-LEFT)

- [method] MCAR (PROJECT-RIGHT PROJECT-RIGHT)

- [method] MCADR (PROJECT-RIGHT PROJECT-RIGHT)

    Right projection (product elimination)

### Accessors

These functions relate to grabbing slots out of the various
@GEB-SUBSTMORPH and @GEB-SUBSTMU types. See those sections for
specific instance documentation

- [generic-function] MCAR OBJECT

- [generic-function] MCADR OBJECT

- [generic-function] MCDR OBJECT

- [generic-function] MCADDR OBJECT

- [generic-function] OBJ OBJECT

- [generic-function] NAME OBJECT

- [generic-function] FUNC OBJECT

### Constructors

The API for creating GEB terms. All the functions and variables
here relate to instantiating a term

- [variable] *SO0* s-0

    The Initial Object

- [variable] *SO1* s-1

    The Terminal Object

More Ergonomic API variants for *SO0* and *SO1*

- [symbol-macro] SO0

- [symbol-macro] SO1

- [function] MAKE-ALIAS &KEY NAME OBJ

- [function] <-LEFT MCAR MCADR

    projects left constructor

- [function] <-RIGHT MCAR MCADR

    projects right constructor

- [function] LEFT-> MCAR MCADR

    injects left constructor

- [function] RIGHT-> MCAR MCADR

    injects right constructor

- [function] MCASE MCAR MCADR

- [function] MAKE-FUNCTOR &KEY OBJ FUNC

### api

Various functions that make working with GEB easier

- [function] PAIR-TO-LIST PAIR &OPTIONAL ACC

    converts excess pairs to a list format

- [function] SAME-TYPE-TO-LIST PAIR TYPE &OPTIONAL ACC

    converts the given type to a list format

- [function] MLIST V1 &REST VALUES

- [function] COMMUTES X Y

- [function] !-> A B

- [function] SO-EVAL X Y

### Examples

PLACEHOLDER: TO SHOW OTHERS HOW EXAMPLES WORK

Let's see the transcript of a real session of someone working
with GEB:

```common-lisp
(values (princ :hello) (list 1 2))
.. HELLO
=> :HELLO
=> (1 2)

(+ 1 2 3 4)
=> 10
```


## Mixins

###### \[in package GEB.MIXINS\]
Various [mixins](https://en.wikipedia.org/wiki/Mixin) of the
project. Overall all these offer various services to the rest of the
project

### Pointwise Mixins

Here we provide various mixins that deal with classes in a pointwise
manner. Normally, objects can not be compared in a pointwise manner,
instead instances are compared. This makes functional idioms like
updating a slot in a pure manner (allocating a new object), or even
checking if two objects are `EQUAL`-able adhoc. The pointwise API,
however, derives the behavior and naturally allows such idioms

- [class] POINTWISE-MIXIN

    Provides the service of giving point wise
    operations to classes

Further we may wish to hide any values inherited from our superclass
due to this we can instead compare only the slots defined directly
in our class

- [class] DIRECT-POINTWISE-MIXIN POINTWISE-MIXIN

    Works like POINTWISE-MIXIN, however functions on
    POINTWISE-MIXIN will only operate on direct-slots
    instead of all slots the class may contain.
    
    Further all `DIRECT-POINTWISE-MIXIN`'s are POINTWISE-MIXIN's

### Pointwise API

These are the general API functions on any class that have the
POINTWISE-MIXIN service.

Functions like TO-POINTWISE-LIST allow generic list traversal APIs to
be built off the key-value pair of the raw object form, while
OBJ-EQUALP allows the checking of functional equality between
objects. Overall the API is focused on allowing more generic
operations on classes that make them as useful for generic data
traversal as `LIST`'s are

- [generic-function] TO-POINTWISE-LIST OBJ

    Turns a given object into a pointwise LIST. listing
    the KEYWORD slot-name next to their value.

- [generic-function] OBJ-EQUALP OBJECT1 OBJECT2

    Compares objects with pointwise equality. This is a
    much weaker form of equality comparison than
    STANDARD-OBJECT EQUALP, which does the much
    stronger pointer quality

- [generic-function] POINTWISE-SLOTS OBJ

    Works like C2MOP:COMPUTE-SLOTS however on the object
    rather than the class

### Mixins Examples

Let's see some example uses of POINTWISE-MIXIN:

```common-lisp
(obj-equalp (geb:terminal geb:so1)
            (geb:terminal geb:so1))
=> t

(to-pointwise-list (geb:coprod geb:so1 geb:so1))
=> ((:MCAR . s-1) (:MCADR . s-1))
```


* * *
###### \[generated by [MGL-PAX](https://github.com/melisgl/mgl-pax)\]
